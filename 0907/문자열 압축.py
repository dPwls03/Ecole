def solution(s):
    # 초기 답을 문자열의 전체 길이로 설정
    # 압축되지 않을 경우의 최악의 경우는 문자열 그대로의 길이가 됨
    answer = len(s) 
    
    # 문자열을 1개 단위부터 len(s) // 2 개 단위까지 쪼개어 압축을 시도함
    # 문자열 절반을 넘는 길이로 자르면 압축의 의미가 없으므로 len(s) // 2까지만 시도
    for x in range(1, len(s) // 2 + 1):
        
        # 각 단위별로 압축된 문자열의 길이를 추적할 변수
        comp_len = 0
        
        # 비교를 위한 첫 번째 문자열 (초기 값은 공백으로 설정)
        comp = ''
        
        # 동일한 문자열이 연속되는 횟수를 셀 변수
        cnt = 1
        
        # 문자열을 x 단위로 나누어 검사 (0부터 len(s) + 1까지 x 간격으로 잘라서 확인)
        for i in range(0, len(s) + 1, x):
            
            # 현재 위치에서 x 길이만큼 문자열을 추출
            temp = s[i:i + x]
            
            # 이전에 추출한 문자열과 현재 문자열이 동일한 경우
            # 이는 동일한 문자열이 반복된 경우를 의미함
            if comp == temp:
                # 반복 횟수를 증가시킴
                cnt += 1
            else:
                # 만약 이전에 동일한 문자열이 있었다면 그 문자열을 압축된 형태로 계산
                # 이전 문자열의 길이를 더함
                comp_len += len(temp)
                # 연속된 문자열이 2번 이상 나왔을 경우, 반복 횟수도 길이에 반영해야 함
                # 예를 들어, "a"가 3번 반복되면 압축된 형태는 "3a"이므로 '3'의 길이만큼 추가
                if cnt > 1:
                    comp_len += len(str(cnt))               
                # 새로운 문자열을 비교 대상으로 설정
                cnt = 1
                comp = temp       
        # 각 자른 단위에 대해 계산된 압축된 문자열의 길이를 최소 길이로 갱신
        answer = min(answer, comp_len)    
    # 최종적으로 가장 짧게 압축된 문자열의 길이를 반환
    return answer
# 입력 문자열 "aabbaccc"는 "2a2ba3c"로 압축될 수 있으며, 그 길이는 7임
print(solution("aabbaccc"))  # 결과: 7

